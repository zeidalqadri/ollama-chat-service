{
  "name": "09 - Harmony Ingest",
  "active": true,
  "nodes": [
    {
      "parameters": {
        "path": "harmony/ingest",
        "httpMethod": "POST",
        "options": {}
      },
      "id": "webhook",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "harmony-ingest-webhook"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body;\nconst validSources = ['smartgep', 'eperolehan', 'mytender', 'manual', 'zakupsk'];\n\nif (!body.source || !validSources.includes(body.source.toLowerCase())) {\n  throw new Error('Invalid source');\n}\n\n// Check if tenders array is valid\nconst hasTenders = body.tenders && Array.isArray(body.tenders) && body.tenders.length > 0;\nconst hasRawHtml = body.raw_html && body.raw_html.length > 0;\n\nif (!hasTenders && !hasRawHtml) {\n  throw new Error('No tenders and no raw_html for recovery');\n}\n\n// If we have tenders, process them normally\nif (hasTenders) {\n  return body.tenders.map(t => ({\n    json: {\n      source: body.source.toLowerCase(),\n      job_id: body.job_id || 'manual-' + Date.now(),\n      source_tender_id: t.tender_id || t.reference || t.id,\n      source_url: t.source_url || t.url || null,\n      raw_data: JSON.stringify(t),\n      scraped_at: new Date().toISOString(),\n      needs_troubleshoot: false\n    }\n  }));\n}\n\n// No tenders but have raw_html - needs troubleshooting\nreturn [{\n  json: {\n    source: body.source.toLowerCase(),\n    job_id: body.job_id || 'manual-' + Date.now(),\n    raw_html: body.raw_html,\n    source_url: body.source_url || null,\n    scraped_at: new Date().toISOString(),\n    needs_troubleshoot: true,\n    error: 'Empty tenders array - attempting extraction from raw HTML'\n  }\n}];"
      },
      "id": "validate",
      "name": "Validate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "jsCode": "// Code filter: Route items that need troubleshooting\n// With rate limiting: max 3 troubleshoot calls per minute\nconst item = $input.first().json;\n\nif (!item.needs_troubleshoot) {\n  return [];  // Skip - go to normal path\n}\n\n// Rate limit check using static data\nconst now = Date.now();\nconst rateLimitWindow = 60000; // 1 minute\nconst maxCallsPerWindow = 3;\n\n// Get or initialize rate limit state\nlet staticData = $getWorkflowStaticData('global');\nif (!staticData.troubleshootCalls) {\n  staticData.troubleshootCalls = [];\n}\n\n// Clean up old calls outside window\nstaticData.troubleshootCalls = staticData.troubleshootCalls.filter(t => now - t < rateLimitWindow);\n\n// Check if we're at the limit\nif (staticData.troubleshootCalls.length >= maxCallsPerWindow) {\n  // Rate limited - skip troubleshooting, mark for manual review\n  return [{\n    json: {\n      ...item,\n      needs_troubleshoot: false,\n      status: 'rate_limited',\n      raw_data: JSON.stringify({\n        _rate_limited: true,\n        _error: item.error,\n        _raw_html_length: (item.raw_html || '').length,\n        _needs_manual_review: true\n      })\n    }\n  }];\n}\n\n// Record this call and continue\nstaticData.troubleshootCalls.push(now);\nreturn $input.all();"
      },
      "id": "filter-needs-troubleshoot",
      "name": "Filter: Needs Troubleshoot",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "jsCode": "// Code filter: Route items that DON'T need troubleshooting\nconst item = $input.first().json;\n\nif (!item.needs_troubleshoot) {\n  return $input.all();  // Continue to Store\n}\nreturn [];  // Skip - goes to troubleshoot path"
      },
      "id": "filter-normal-path",
      "name": "Filter: Normal Path",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.BORAK_URL || 'http://localhost:8012' }}/api/troubleshoot",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  stage: 'extract',\n  error_data: {\n    error: $json.error,\n    url: $json.source_url,\n    partial_data: {},\n    missing_fields: ['tender_id', 'title', 'organization', 'closing_date']\n  },\n  context: {\n    raw_html: $json.raw_html\n  }\n}) }}",
        "options": {
          "timeout": 90000
        }
      },
      "id": "troubleshoot-extract",
      "name": "Troubleshoot Extract",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Process troubleshoot response with circuit breaker\nconst original = $('Filter: Needs Troubleshoot').first().json;\nconst troubleshootResult = $json;\n\n// Circuit breaker: track failures\nlet staticData = $getWorkflowStaticData('global');\nif (!staticData.troubleshootFailures) {\n  staticData.troubleshootFailures = 0;\n  staticData.lastTroubleshootSuccess = Date.now();\n}\n\n// Check if HTTP request failed\nconst httpFailed = troubleshootResult.error || troubleshootResult.statusCode >= 400;\n\nif (httpFailed) {\n  staticData.troubleshootFailures++;\n  \n  // Return failure result\n  return [{\n    json: {\n      source: original.source,\n      job_id: original.job_id,\n      source_tender_id: 'failed-extraction-' + Date.now(),\n      source_url: original.source_url,\n      raw_data: JSON.stringify({\n        _extraction_failed: true,\n        _diagnosis: 'API call failed: ' + (troubleshootResult.error || troubleshootResult.statusCode),\n        _raw_html_length: (original.raw_html || '').length,\n        _needs_manual_review: true\n      }),\n      scraped_at: original.scraped_at,\n      status: 'failed_extraction'\n    }\n  }];\n}\n\n// Reset failure counter on success\nstaticData.troubleshootFailures = 0;\nstaticData.lastTroubleshootSuccess = Date.now();\n\n// Check if recovery was successful\nif (troubleshootResult.recovered && troubleshootResult.data) {\n  const extracted = troubleshootResult.data;\n  return [{\n    json: {\n      source: original.source,\n      job_id: original.job_id,\n      source_tender_id: extracted.tender_id || extracted.id || 'recovered-' + Date.now(),\n      source_url: original.source_url,\n      raw_data: JSON.stringify({\n        ...extracted,\n        _recovered: true,\n        _recovery_confidence: troubleshootResult.confidence,\n        _diagnosis: troubleshootResult.diagnosis\n      }),\n      scraped_at: original.scraped_at,\n      recovered: true\n    }\n  }];\n}\n\n// Recovery failed - log for manual review\nreturn [{\n  json: {\n    source: original.source,\n    job_id: original.job_id,\n    source_tender_id: 'failed-extraction-' + Date.now(),\n    source_url: original.source_url,\n    raw_data: JSON.stringify({\n      _extraction_failed: true,\n      _diagnosis: troubleshootResult.diagnosis || 'Unknown failure',\n      _raw_html_length: (original.raw_html || '').length,\n      _needs_manual_review: true\n    }),\n    scraped_at: original.scraped_at,\n    status: 'failed_extraction'\n  }\n}];"
      },
      "id": "process-troubleshoot",
      "name": "Process Troubleshoot",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO raw_tenders (source, source_tender_id, source_url, job_id, raw_data, scraped_at, status) VALUES ('{{ $json.source }}', '{{ $json.source_tender_id }}', {{ $json.source_url ? \"'\" + $json.source_url + \"'\" : 'NULL' }}, '{{ $json.job_id }}', '{{ $json.raw_data }}'::jsonb, '{{ $json.scraped_at }}'::timestamptz, '{{ $json.status || \"pending\" }}') ON CONFLICT (source, source_tender_id) DO UPDATE SET raw_data = EXCLUDED.raw_data, scraped_at = EXCLUDED.scraped_at, status = EXCLUDED.status, updated_at = NOW() RETURNING id::text, source_tender_id, (xmax = 0) as is_new",
        "options": {}
      },
      "id": "store",
      "name": "Store",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1340, 300],
      "credentials": {"postgres": {"id": "postgres-bidding", "name": "Postgres Bidding DB"}}
    },
    {
      "parameters": {
        "jsCode": "// Filter: Only forward successfully stored pending records to WF10\nconst item = $input.first().json;\n\n// Skip failed extractions - they don't have valid data for WF10\nconst status = item.status || 'pending';\nif (status === 'failed_extraction' || status === 'rate_limited') {\n  return [];  // Skip - will still go to Aggregate via merge\n}\n\n// Forward to WF10 for processing\nreturn $input.all();"
      },
      "id": "filter-for-wf10",
      "name": "Filter: For WF10",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://localhost:5678/webhook/harmony/process",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  raw_tender_id: $json.id,\n  source: $('Validate').first().json.source,\n  source_tender_id: $json.source_tender_id,\n  raw_data: $('Validate').first().json.raw_data || $('Process Troubleshoot').first()?.json?.raw_data\n}) }}",
        "options": { "timeout": 30000 }
      },
      "id": "call-wf10",
      "name": "Call WF10",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1780, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const items = $input.all();\nconst recovered = items.filter(i => i.json.recovered);\nconst failed = items.filter(i => i.json.status === 'failed_extraction' || i.json.status === 'rate_limited');\nconst processed = items.filter(i => !i.json.status || i.json.status === 'pending');\n\nreturn [{ json: {\n  success: true,\n  total: items.length,\n  new_tenders: items.filter(i => i.json.is_new).length,\n  sent_to_wf10: processed.length,\n  recovered_count: recovered.length,\n  failed_count: failed.length,\n  ids: items.map(i => ({\n    id: i.json.id,\n    tender: i.json.source_tender_id,\n    is_new: i.json.is_new,\n    recovered: i.json.recovered || false\n  }))\n} }];"
      },
      "id": "aggregate",
      "name": "Aggregate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "jsCode": "// Code filter: Check if there are failures to alert\nconst data = $input.first().json;\n\nif (data.failed_count > 0) {\n  return $input.all();  // Continue to alert\n}\nreturn [];  // No failures, skip alert"
      },
      "id": "filter-has-failures",
      "name": "Filter: Has Failures",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 300]
    },
    {
      "parameters": {
        "operation": "sendMessage",
        "chatId": "={{ $env.TELEGRAM_INTAKE_GROUP }}",
        "text": "={{ `‚ö†Ô∏è HARMONY INGEST WARNING\n\nüìã Job: ${$('Aggregate').first().json.job_id || 'unknown'}\n‚úÖ Processed: ${$json.processed}\nüîÑ Recovered: ${$json.recovered_count}\n‚ùå Failed: ${$json.failed_count}\n\nüëÄ Some extractions failed and require manual review.` }}",
        "additionalFields": {}
      },
      "id": "telegram-alert-failures",
      "name": "Alert: Extraction Failures",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [2440, 300],
      "credentials": {
        "telegramApi": {
          "id": "telegram-bidding-bot",
          "name": "Bidding Bot"
        }
      },
      "continueOnFail": true
    }
  ],
  "connections": {
    "Webhook": {"main": [[{"node": "Validate", "type": "main", "index": 0}]]},
    "Validate": {
      "main": [[
        {"node": "Filter: Normal Path", "type": "main", "index": 0},
        {"node": "Filter: Needs Troubleshoot", "type": "main", "index": 0}
      ]]
    },
    "Filter: Normal Path": {"main": [[{"node": "Store", "type": "main", "index": 0}]]},
    "Filter: Needs Troubleshoot": {"main": [[{"node": "Troubleshoot Extract", "type": "main", "index": 0}]]},
    "Troubleshoot Extract": {"main": [[{"node": "Process Troubleshoot", "type": "main", "index": 0}]]},
    "Process Troubleshoot": {"main": [[{"node": "Store", "type": "main", "index": 0}]]},
    "Store": {"main": [[{"node": "Filter: For WF10", "type": "main", "index": 0}, {"node": "Aggregate", "type": "main", "index": 0}]]},
    "Filter: For WF10": {"main": [[{"node": "Call WF10", "type": "main", "index": 0}]]},
    "Aggregate": {"main": [[{"node": "Filter: Has Failures", "type": "main", "index": 0}]]},
    "Filter: Has Failures": {"main": [[{"node": "Alert: Extraction Failures", "type": "main", "index": 0}]]}
  },
  "settings": {"executionOrder": "v1", "saveManualExecutions": true},
  "staticData": null,
  "tags": [{"name": "harmony-pipeline"}, {"name": "code-filter-pattern"}, {"name": "rate-limited"}],
  "triggerCount": 1,
  "versionId": "3.1.0"
}
